
==================== FINAL INTERFACE ====================
2017-02-05 17:47:16.404179817 UTC

interface assign2-0.1.0.0-HR9hU8cIXLf43tgzC2vdOI:Parser 8001
  interface hash: b4318474c64698052733dfa23e63a463
  ABI hash: a5ced037bd9ac6e380baf0fcfd30c5ed
  export-list hash: 25285b630bd52bf2da1b224fb3f8cd24
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2e0f534c8a07bc37de10c22bd4265981
  sig of: Nothing
  used TH splices: False
  where
exports:
  Parser.parseInput
module dependencies: AST Token
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:GHC.Exts
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  array-0.5.1.1@array-0.5.1.1:Data.Array 01310623526f8acc73d1bb69e9d9530a
import  -/  AST 7b5c22e1e68d6355c9342be5dded0584
  exports: 2b09893de07e573487a38dddb47ef3ca
  B_Else 40d0e38da5fe2c12b3f13d58d1df8a35
  B_Endif 6e5793039af426f5a7ab2562f9088157
  D_Decl d65f4af2df8fa883c8b0821474e1bde0
  E_Add 4541553b8d71491796e0d47b23281a22
  E_Div cefb30bfe7016cb841ac40533dc4e790
  E_Float a3551181c698b4f0741c6f0989adcdbe
  E_Iden ee5a02d4185b6017cc674446486a01c1
  E_Int 4b7b7194f867d7c6ec7e626e701fedb7
  E_Mult eedb11fc1802483a26994407260d438f
  E_Paren 9b0fe02cdb2a5bb57f76a0717b37e967
  E_String f971d508e74c94063dccd7293bab1fe1
  E_Sub aa5042ab5e1a5e81584ac8ad96dd20cc
  E_UMinus 411bcba97b08cf3c2ee29bf5a5d2cef4
  Prog 918dbd3f46e2cb0d5813954f7ddd7243
  S_Assign bc1b14b61d464ec80040db940f260486
  S_If 6f1e5a74efbd9b6874e87b40443ba8d6
  S_Print 1ccae0cfaaaa29255e4c1fec504256f8
  S_Read 0377b1614c4e5ac0d0253a281d5b417f
  S_While 50c88648696744603b40a95d59ea2557
  T_Float 5cef660a56101ae71d6cabdf23eadba3
  T_Int db4d3c8700cb718cf9f2c28c06141260
  T_String 19e6f970f152e51079200edc21045892
import  -/  Token e897ad80613966aa5abd8d1469d9012c
  exports: 5cfdc964f38b953af54dd1f54cfaa251
  TADD 3c1f5c9eacf21974bc4a46f29d8bc50b
  TDIV 1978eca3842d2ff07f7e68384e23ea73
  TDO a5661bba5b186a1a30c75f3c35fd8ae7
  TDONE 16d98306abcddf5f12eb3a92d2779bc6
  TELSE 9ec56b0cd974124586eafbdec441db2e
  TENDIF c668b23e46862e05a5df10e1eee0b369
  TEQUALS 6c8870af74d2e6c88b0ece182cb89c75
  TFLOAT 88b11caa2d20f7c268e0c087c8c7135f
  TIF 4cc932aa6e01b11747ec1fbf3edcc75a
  TINT 5e94fcef65df2eb5f1096da56d7f76cb
  TMULT 65cd6562b53b7fa4e429cb9c76df066d
  TPRINT 3b5ac4d9d7ae4a04778b65bddd449d83
  TREAD f68864553237e812870b49155eefc190
  TSTRING 041f3b67d7645b86a54b9d2cea899d1f
  TSUB 86a450ce759d8ddb085c343113ba55d6
  TTHEN be27cbdb2f332c3995be159b27b33294
  TVAR acc49ed1f536b035d2a39519000bab42
  TWHILE a1c0d76125b4e3006d6eda444b9e4bad
  T_CBRACE 66a644027faedfa1ae018986d925867d
  T_COLON 5a60fbb31c83dd4c37d4fb15ea0e0da2
  T_CPAREN 7f477b1521b93eb76211d36de6fa04d9
  T_DQUOTE f997a93fde99d81dd84d8668f37b3077
  T_FLOAT_VAL 5cc9bd81cc91f360e7cc2ae75bf974a0
  T_ID_VAL cfe272c30e86d1b24dbca252114b4d59
  T_INT_VAL ffbee5ac7be484fb84c770fff88bb3a6
  T_OBRACE 198d1d0fb98c6c878ea7a61d9370704d
  T_OPAREN 7de216312ab9d1945416ece0cea40cc3
  T_SCOLON a4a87f0c52efee07e52714863173e893
  T_STRING_VAL 49ec684c8967860e4e1e0122b6d96773
  Token 71e1b87689efd694bd8275cfc62f5b27
import  -/  base-4.9.0.0:Control.Applicative 7728b33d6969dce59e89474349eb1397
import  -/  base-4.9.0.0:Control.Monad 7767aebfd53f0b584cef2fe66ad3986c
import  -/  base-4.9.0.0:GHC.Arr fbccefe7cac601823d07f61ad7e915a2
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Exts 79bfb724def0ed3fd4411241036c8cc5
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
addDependentFile "/home/yiqiao/.stack/programs/x86_64-linux/ghc-ncurses6-8.0.1/lib/ghc-8.0.1/include/ghcversion.h"
addDependentFile "/usr/include/stdc-predef.h"
addDependentFile ".stack-work/dist/x86_64-linux-ncurses6/Cabal-1.24.0.0/build/autogen/cabal_macros.h"
fixities infixr 9 HappyStk, infixr 9 HappyStk
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity ::
    GHC.Base.Applicative Parser.HappyIdentity
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.HappyIdentity
                  Parser.$fFunctorHappyIdentity
                  Parser.$fApplicativeHappyIdentity_$creturn
                  Parser.$fApplicativeHappyIdentity_$c<*>
                  Parser.$fApplicativeHappyIdentity_$c*>
                  Parser.$fApplicativeHappyIdentity_$c<* -}
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity1 ::
    forall {a} {b}.
    Parser.HappyIdentity a
    -> Parser.HappyIdentity b -> Parser.HappyIdentity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ b
                   (eta :: Parser.HappyIdentity a)
                   (eta1 :: Parser.HappyIdentity b) ->
                 eta) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity2 ::
    forall {a} {b}.
    Parser.HappyIdentity (a -> b) -> Parser.HappyIdentity a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ b
                   (m1 :: Parser.HappyIdentity (a -> b))
                   (m2 :: Parser.HappyIdentity a) ->
                 m1 `cast` (Parser.N:HappyIdentity[0] <a -> b>_R)
                   m2 `cast` (Parser.N:HappyIdentity[0] <a>_R)) -}
78f8c76886dae8ec6c3e83918675a1d4
  $fApplicativeHappyIdentity3 :: forall {a}. a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ a (tpl :: a) -> tpl) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity_$c*> ::
    forall a b.
    Parser.HappyIdentity a
    -> Parser.HappyIdentity b -> Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ b
                   (eta :: Parser.HappyIdentity a)
                   (eta1 :: Parser.HappyIdentity b) ->
                 eta1) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity_$c<* ::
    forall a b.
    Parser.HappyIdentity a
    -> Parser.HappyIdentity b -> Parser.HappyIdentity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity1 -}
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity_$c<*> ::
    forall a b.
    Parser.HappyIdentity (a -> b)
    -> Parser.HappyIdentity a -> Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Parser.HappyIdentity (a -> b)>_R
                 ->_R <Parser.HappyIdentity a>_R
                 ->_R Sym (Parser.N:HappyIdentity[0] <b>_R)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fApplicativeHappyIdentity_$creturn ::
    forall a. a -> Parser.HappyIdentity a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity3
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R ->_R Sym (Parser.N:HappyIdentity[0] <a>_R)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fFunctorHappyIdentity :: GHC.Base.Functor Parser.HappyIdentity
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.HappyIdentity
                  Parser.$fFunctorHappyIdentity_$cfmap
                  Parser.$fFunctorHappyIdentity_$c<$ -}
d452fc20a2924c5d472e5c78d9c53af4
  $fFunctorHappyIdentity1 ::
    forall {a} {b}. a -> Parser.HappyIdentity b -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (eta :: a) (ds :: Parser.HappyIdentity b) -> eta) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fFunctorHappyIdentity2 ::
    forall {a} {b}. (a -> b) -> Parser.HappyIdentity a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (f :: a -> b) (ds :: Parser.HappyIdentity a) ->
                 f ds `cast` (Parser.N:HappyIdentity[0] <a>_R)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fFunctorHappyIdentity_$c<$ ::
    forall a b. a -> Parser.HappyIdentity b -> Parser.HappyIdentity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fFunctorHappyIdentity1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <Parser.HappyIdentity b>_R
                 ->_R Sym (Parser.N:HappyIdentity[0] <a>_R)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fFunctorHappyIdentity_$cfmap ::
    forall a b.
    (a -> b) -> Parser.HappyIdentity a -> Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fFunctorHappyIdentity2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Parser.HappyIdentity a>_R
                 ->_R Sym (Parser.N:HappyIdentity[0] <b>_R)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fMonadHappyIdentity :: GHC.Base.Monad Parser.HappyIdentity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.HappyIdentity
                  Parser.$fMonadHappyIdentity_$cp1Monad
                  Parser.$fMonadHappyIdentity_$c>>=
                  Parser.$fMonadHappyIdentity_$c>>
                  Parser.$fApplicativeHappyIdentity_$creturn
                  Parser.$fMonadHappyIdentity_$s$dmfail -}
d452fc20a2924c5d472e5c78d9c53af4
  $fMonadHappyIdentity_$c>> ::
    forall a b.
    Parser.HappyIdentity a
    -> Parser.HappyIdentity b -> Parser.HappyIdentity b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Parser.HappyIdentity a)
                   (k :: Parser.HappyIdentity b) ->
                 Parser.$fMonadHappyIdentity_$c>>=
                   @ a
                   @ b
                   m1
                   (\ (ds :: a)[OneShot] -> k)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fMonadHappyIdentity_$c>>= ::
    forall a b.
    Parser.HappyIdentity a
    -> (a -> Parser.HappyIdentity b) -> Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ b
                   (ds :: Parser.HappyIdentity a)
                   (q :: a -> Parser.HappyIdentity b) ->
                 q ds `cast` (Parser.N:HappyIdentity[0] <a>_R)) -}
d452fc20a2924c5d472e5c78d9c53af4
  $fMonadHappyIdentity_$cp1Monad ::
    GHC.Base.Applicative Parser.HappyIdentity
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity -}
d452fc20a2924c5d472e5c78d9c53af4
  $fMonadHappyIdentity_$s$dmfail ::
    forall a. GHC.Base.String -> Parser.HappyIdentity a
  {- Arity: 1, Strictness: <B,U>x,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a (s :: GHC.Base.String) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.PtrRepLifted
                   @ (Parser.HappyIdentity a)
                   s) -}
04c4ea4bed47fdc3cb18154918418068
  $tc'HappyA# :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14794509533584292200##
                   14061089995896554832##
                   Parser.$trModule
                   Parser.$tc'HappyA#1) -}
b1390c40a57c8e11011310db6e8a0c34
  $tc'HappyA#1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyA#"#) -}
3c071f7f1f27d5e56f7c8cdc841cba21
  $tc'HappyAbsSyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13699020364550222422##
                   11113613573385958432##
                   Parser.$trModule
                   Parser.$tc'HappyAbsSyn1) -}
c0518e506dd1431ac150203ecb67c24d
  $tc'HappyAbsSyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyAbsSyn"#) -}
299cad0404b40fdf9ecf0f1e56a9342c
  $tc'HappyCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10972419322709878787##
                   6837580104014674068##
                   Parser.$trModule
                   Parser.$tc'HappyCons1) -}
4b253e8992ca5df3189941f1334fcb49
  $tc'HappyCons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyCons"#) -}
3e8523d857d98dd93d48617d0d0b4ca2
  $tc'HappyIdentity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1845030735876291782##
                   17389174123954045837##
                   Parser.$trModule
                   Parser.$tc'HappyIdentity1) -}
db7fbe0e78a4ec17ab69624d2362a34f
  $tc'HappyIdentity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyIdentity"#) -}
251338f752781e5a7424c7162daf8bfa
  $tc'HappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7873787214375025803##
                   7125170007778199395##
                   Parser.$trModule
                   Parser.$tc'HappyStk1) -}
1ea24abce0f1c4ce43ff444e9b67ac60
  $tc'HappyStk1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyStk"#) -}
012f976699c73de3b2572ebcece76c98
  $tcHappyAbsSyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8370229258780589691##
                   16716595629808402242##
                   Parser.$trModule
                   Parser.$tcHappyAbsSyn1) -}
1a116f4ef5387288b24fe96e6ec089dc
  $tcHappyAbsSyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyAbsSyn"#) -}
6f0e262f859d41e7c3f47c7752008b4a
  $tcHappyAddr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7741057913842752435##
                   16225219929040139342##
                   Parser.$trModule
                   Parser.$tcHappyAddr1) -}
2573aea91047896d7b1d0f1a4d4e399d
  $tcHappyAddr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyAddr"#) -}
707b114cddade1340fea798b1ecb468a
  $tcHappyIdentity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4822876234013571643##
                   16894779708737589028##
                   Parser.$trModule
                   Parser.$tcHappyIdentity1) -}
f6cbe64b309c10dc76be9147ad11ebc2
  $tcHappyIdentity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyIdentity"#) -}
2cfa911375674617392ffe65d851e79a
  $tcHappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9754274342284918787##
                   3783091635826389572##
                   Parser.$trModule
                   Parser.$tcHappyStk1) -}
4425d708114e8fcca5a8cd24818e8fd5
  $tcHappyStk1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyStk"#) -}
3dfc30e83321570c646dbdd3289830dd
  $tcHappy_IntList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4993921793220106244##
                   8494899320976797339##
                   Parser.$trModule
                   Parser.$tcHappy_IntList1) -}
372099e126f8228b0b43e68cae68ccaa
  $tcHappy_IntList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Happy_IntList"#) -}
242adda2f4cd694e4cd4ec28f50cf476
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Parser.$trModule2
                   Parser.$trModule1) -}
cc4eaf23042b109facefde892f2f883d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Parser"#) -}
686b59e9f25b712bce46f0e718dfa569
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "assign2-0.1.0.0-HR9hU8cIXLf43tgzC2vdOI"#) -}
51f314d078083113a2fdde4b5908bac3
  type role HappyAbsSyn phantom phantom phantom phantom phantom phantom phantom phantom
  newtype HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11
    = HappyAbsSyn Parser.HappyAny
b96bcaac253da46e93f75be0663a2d4e
  data HappyAddr = HappyA# GHC.Prim.Addr#
f2a18bcb8f496194604e6976e119c972
  type HappyAny = GHC.Prim.Any
d452fc20a2924c5d472e5c78d9c53af4
  newtype HappyIdentity a = HappyIdentity a
b2d9ed7ccddf8740f44c590cbdd534b8
  data HappyStk a = HappyStk a (Parser.HappyStk a)
    RecFlag: Recursive
3c9fe35dadbde363e6f318b05d24f220
  data Happy_IntList = HappyCons GHC.Prim.Int# Parser.Happy_IntList
    RecFlag: Recursive
f70c853a97002462d269bf48e3e8ac26
  notHappyAtAll :: forall a. a
  {- Strictness: x -}
3097d12f0682b6a68e3617750e27dcc7
  parseInput :: [Token.Token] -> AST.Prog
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.parseInput1
                  `cast`
                (<[Token.Token]>_R
                 ->_R Parser.N:HappyIdentity[0]
                          (UnsafeCo representational (Parser.HappyAbsSyn
                                                        AST.Prog
                                                        [AST.Decl]
                                                        [AST.Stmt]
                                                        AST.Type
                                                        AST.Decl
                                                        AST.Stmt
                                                        AST.ElseBlock
                                                        AST.Expr) AST.Prog)) -}
77a780ea5b6c200a5b0d3aa7c9534590
  parseInput1 ::
    [Token.Token]
    -> Parser.HappyIdentity
         (Parser.HappyAbsSyn
            AST.Prog
            [AST.Decl]
            [AST.Stmt]
            AST.Type
            AST.Decl
            AST.Stmt
            AST.ElseBlock
            AST.Expr)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (tks :: [Token.Token]) ->
                 Parser.parseInput_happyNewToken
                   0#
                   (Parser.notHappyAtAll @ Parser.Happy_IntList)
                   (Parser.notHappyAtAll
                      @ (Parser.HappyStk
                           (Parser.HappyAbsSyn
                              AST.Prog
                              [AST.Decl]
                              [AST.Stmt]
                              AST.Type
                              AST.Decl
                              AST.Stmt
                              AST.ElseBlock
                              AST.Expr)))
                   tks) -}
a5e9c2c26b202dc5c297ddf93f7d0706
  parseInput_happyNewToken ::
    GHC.Prim.Int#
    -> Parser.Happy_IntList
    -> Parser.HappyStk
         (Parser.HappyAbsSyn
            AST.Prog
            [AST.Decl]
            [AST.Stmt]
            AST.Type
            AST.Decl
            AST.Stmt
            AST.ElseBlock
            AST.Expr)
    -> [Token.Token]
    -> Parser.HappyIdentity
         (Parser.HappyAbsSyn
            AST.Prog
            [AST.Decl]
            [AST.Stmt]
            AST.Type
            AST.Decl
            AST.Stmt
            AST.ElseBlock
            AST.Expr)
  {- Arity: 4, Strictness: <S,U><L,U><L,U(U,U(U,U))><S,1*U> -}
instance GHC.Base.Applicative [Parser.HappyIdentity]
  = Parser.$fApplicativeHappyIdentity
instance GHC.Base.Functor [Parser.HappyIdentity]
  = Parser.$fFunctorHappyIdentity
instance GHC.Base.Monad [Parser.HappyIdentity]
  = Parser.$fMonadHappyIdentity
"SPEC/Parser $dmfail @ HappyIdentity" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                                    Parser.HappyIdentity)
  GHC.Base.$dmfail @ Parser.HappyIdentity $dMonad
  = Parser.$fMonadHappyIdentity_$s$dmfail
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

